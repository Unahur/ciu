# ES6: Modules{docsify-ignore-all}

## ¬øPara qu√© sirven?

- Los m√≥dulos nos permiten exportar e importar diferentes partes de c√≥digo, entre diferentes archivos, lo cual nos permite modularizar el c√≥digo
- Un m√≥dulo no es m√°s que un archivo (en este caso JS) que importamos/exportamos desde o hacia otro archivo para utilizarlo
- _Definici√≥n cheta:_ un m√≥dulo es una unidad independiente (autocontenida) de c√≥digo reutilizable, que podemos exportar para luego importarla y utilizarla en otro archivo (√≥ m√≥dulo)
- _Otra:_ los m√≥dulos nos permiten _encapsular_ funcionalidad y exponerla a otros archivos JS, como si se tratase de _librer√≠as_ (biliotecas)

## Motivaci√≥n (o sea... ¬øpor qu√© usarlos?)

- **Para organizar mejor nuestro c√≥digo.**
- Igual, si, **c√≥digo m√°s organizado => c√≥digo m√°s legible, simple, conciso, m√°s f√°cil de razonar => m√°s mantenible** 

![cleandcode](https://media.makeameme.org/created/clean-code-clean.jpg)

### Otros problemas que resuelven los m√≥dulos

- Duplicaci√≥n de c√≥digo
- Namespacing (evitar la colisi√≥n de nombres de variables, funciones, clases, etc)
- Dependency Tree (cargar las dependencias necesarias, en el orden correcto)
- etc

## Antes de ES6 Modules

- Carg√°bamos los diferentes `script` tags a mano en el HTML
  - Si los carg√°bamos en orden incorrecto (seg√∫n las dependencias), no funcionaba
  - Genera problemas de performance/usabilidad: hasta que no se termina de cargar un `script`, no se carga el siguiente y as√≠, porque es _render-blocking_
  - _tl;dr_ Hacer esto a mano es bastante molesto, perdemos mucho tiempo y casi siempre _sale mal_ (la palabra t√©cnica para eso es _error-prone_ üòÅ)
- Antes de _ES6 Modules_, No ten√≠amos una forma nativa (y standard) de c√≥mo usar m√≥dulos en JS 
- M√°s tarde fueron apareciendo diferentes soluciones de terceros (_CommonJS, AMD, UMD, Browserify, etc_) y era medio un complejo por temas de compatibilidad, etc
- Aparecen los _package bundlers/module loaders_ que nos simplifican un poco la vida y hacen el trabajo sucio por nosotros, pero agregamos m√°s herramientas y capas de complejidad a nuestro c√≥digo

## Dependencias e interfaz

- Llamamos **dependencias** a la funcionalidad/valores que importamos en un archivo. Cuando un _m√≥dulo_ importa funcionalidad de otro m√≥dulo, decimos que _depende_ o _tiene como dependencia_ a ese otro m√≥dulo
- Llamamos **interfaz** a la funcionalidad/valores que un m√≥dulo provee (exporta) al resto. Un m√≥dulo s√≥lo puede importar funcionalidad que forme parte de la _interfaz_ de otor m√≥dulo. Todo lo que no se exporta es _privado_ dentro de un m√≥dulo y no puede ser usado fuera del mismo

## ¬øQu√© podemos exportar? (e importar)

- variables/constantes
- objetos
- funciones
- clases

## Soporte

Rec√≠en a mediados del 2018 esta feature comenz√≥ a tener m√°s [soporte](https://caniuse.com/#feat=es6-module), por lo que en algunos browsers posiblemente tengamos que usar herramientas (aka _package bundlers_) como [Webpack](https://webpack.js.org/) o [Parcel](https://parceljs.org/), para compilar nuestros m√≥dulos de ES6 a una sintaxis que el browser entienda.

## Uso

- **Named export:** Lo usamos cuando queremos indicar expl√≠citamente qu√© exportamos y con qu√© nombre. Permite exportar m√∫ltiples valores por archivo. Necesitamos usar `{}` en el `import` y llamarlo con el mismo nombre con el que fue exportado (√≥ usar un _alias_). Si el nombre no matchea con ning√∫n `export`, va a importar el `default`

```js
export const package = {};

import { package } from './module-name.js';
```

```js
// Podemos exportar m√∫ltiples valores
const a = 1;
const b = 2;
const c = 3;

export { a, b, c };

// Y despu√©s importar s√≥lo los que vamos a usar (con destructuring!)
import { a, b } from './module-name.js'

// En el caso de ser necesario, podemos renombrar los imports, suando 'as'
import { a as one } from './module-name.js'
```

- **Default export:** Lo usamos generalmente cuando exportamos un √∫nico valor. S√≥lo puede haber un _default export_ por m√≥dulo. No necesitamos usar `{}` en el `import` y podemos ponerle el nombre que querramos

```js
export default const package = {};

import package from './module-name.js';
```

- ‚ú® **Nota:** podemos usar _named_ y _default exports_ en el mismo m√≥dulo

- **Wildcard export:** Lo usamos si queremos importar _todo_ lo que otro m√≥dulo exporta

```js
const a = 1;
const b = 2;
const c = 3;

export { a, b, c };

// Importamos a, b y c
import * from './module-name.js'
```

```js
// Exportar todos los _named export_ a un objeto
import * as MainComponents from "./MyComponent";
// Usamos MainComponents.MyComponent y MainComponents.MyComponent2 por ejemplo
```

- **Absolute path:** Tambi√©n podemos usar _paths absolutos_ para referenciar m√≥dulos que se encuentran en otro dominio

```js
import toUpperCase from 'https://git.io/fjjGt'
```

## Usando ES6 modules en el browser

- Tenemos que agregar el atributo `type="module"` a nuestros tags `script` para que el browser los cargue como _ES6 Modules_
- Ojo con el tema de [_CORS_](https://www.youtube.com/watch?v=JVZIhCVFJ9c), necesitamos levantar los archivos en un server. Algunas opciones: [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer), [http-server](https://www.npmjs.com/package/http-server)
- Para browsers sin soporte, podemos definir un `script` con al atributo `nomodule` como fallback

```js
<script type="module" src="module.js"></script>
<script nomodule src="fallback.js"></script>
```

## Node

Node utiliza _CommonJS_ como sistema de m√≥dulos desde hace mucho tiempo

```js
const package = require('module-name');
```

Gracias a esta feature de ES6, podemos estandarizar y unificar la forma de usarlos. En la versi√≥n 12, el [soporte para ES6 modules](https://blog.logrocket.com/es-modules-in-node-js-12-from-experimental-to-release/) mejor√≥ mucho

## Tips

- Poner los _imports_ siempre al inicio del archivo JS
- Si el archivo exporta una sola cosa, usar `export default`
- Los _Named imports_ llevan `{}`, los _default_ no
- Si el _path_ no es absoluto, no olvidarnos de usar `./` o `/` antes del nombre del m√≥dulo
- No olvidarnos de ponerle la extensi√≥n `.js` al m√≥dulo que importamos

```js
// Esto no funciona ‚ùå
import { something } from './moduleName';

// Esto si ‚úÖ
import { something } from './moduleName.js';
```

[![JavaScript Modules in 100 Seconds](https://img.youtube.com/vi/qgRUr-YUk1Q/0.jpg)](https://www.youtube.com/watch?v=qgRUr-YUk1Q)

- [Cheatsheet](https://www.samanthaming.com/tidbits/79-module-cheatsheet/)